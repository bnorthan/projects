// generated by Fast Light User Interface Designer (fluid) version 1.0300

#ifndef psfGUI_h
#define psfGUI_h
#include <FL/Fl.H>
#include "psf/psfUser.h"
#include <FL/Fl_Double_Window.H>
#include <FL/Fl_File_Input.H>
#include <FL/Fl_Button.H>
#include <FL/Fl_Progress.H>
#include <FL/Fl_Group.H>
#include <FL/Fl_Round_Button.H>
#include <FL/Fl_Value_Input.H>
#include <FL/Fl_Box.H>
#include <FL/Fl_Choice.H>
#include <FL/Fl_Check_Button.H>

class PsfGUI {
public:
  PsfGUI();
  Fl_Double_Window *psfWindow;
  static Fl_Menu_Item menu_[];
private:
  void cb_Quit_i(Fl_Menu_*, void*);
  static void cb_Quit(Fl_Menu_*, void*);
  void cb_About_i(Fl_Menu_*, void*);
  static void cb_About(Fl_Menu_*, void*);
public:
  Fl_File_Input *filenameInput;
private:
  void cb_Browse_i(Fl_Button*, void*);
  static void cb_Browse(Fl_Button*, void*);
public:
  Fl_Progress *psfProgress;
private:
  void cb_Generate_i(Fl_Button*, void*);
  static void cb_Generate(Fl_Button*, void*);
public:
  Fl_Round_Button *interpolateCheck;
private:
  void cb_interpolateCheck_i(Fl_Round_Button*, void*);
  static void cb_interpolateCheck(Fl_Round_Button*, void*);
public:
  Fl_Round_Button *exactCheck;
private:
  void cb_exactCheck_i(Fl_Round_Button*, void*);
  static void cb_exactCheck(Fl_Round_Button*, void*);
public:
  Fl_Value_Input *psfErrorInput;
  Fl_Value_Input *psfLMInput;
  Fl_Value_Input *psfNAInput;
  Fl_Value_Input *psfLambdaInput;
  Fl_Value_Input *psfCDRIInput;
  Fl_Value_Input *psfCDTInput;
  Fl_Value_Input *psfCARIInput;
  Fl_Value_Input *psfCATInput;
  Fl_Value_Input *psfIMDRIInput;
  Fl_Value_Input *psfIMDTInput;
  Fl_Value_Input *psfIMARIInput;
  Fl_Value_Input *psfIMATInput;
  Fl_Value_Input *psfSRIInput;
  Fl_Value_Input *psfSTInput;
  Fl_Value_Input *psfOTLDInput;
  Fl_Value_Input *psfOTLAInput;
  Fl_Value_Input *psfXSizeInput;
  Fl_Value_Input *psfYSizeInput;
  Fl_Value_Input *psfZSizeInput;
  Fl_Value_Input *psfXSpacingInput;
  Fl_Value_Input *psfYSpacingInput;
  Fl_Value_Input *psfZSpacingInput;
  Fl_Choice *psfModelInput;
  static Fl_Menu_Item menu_psfModelInput[];
  Fl_Choice *psfTypeInput;
  static Fl_Menu_Item menu_psfTypeInput[];
private:
  void cb_Non_i(Fl_Menu_*, void*);
  static void cb_Non(Fl_Menu_*, void*);
  void cb_2_i(Fl_Menu_*, void*);
  static void cb_2(Fl_Menu_*, void*);
  void cb_Confocal_i(Fl_Menu_*, void*);
  static void cb_Confocal(Fl_Menu_*, void*);
  void cb_Confocal1_i(Fl_Menu_*, void*);
  static void cb_Confocal1(Fl_Menu_*, void*);
public:
  Fl_Choice *psfPrecisionInput;
  static Fl_Menu_Item menu_psfPrecisionInput[];
  Fl_Value_Input *psfIntervalInput;
  Fl_Value_Input *psfTotalInput;
  Fl_Check_Button *psfSumCheck;
  Fl_Group *confocalTab;
  Fl_Value_Input *psfMagYInput;
  Fl_Value_Input *psfFSizeInput;
  Fl_Value_Input *psfDistanceInput;
  Fl_File_Input *xmlInput;
private:
  void cb_Browse1_i(Fl_Button*, void*);
  static void cb_Browse1(Fl_Button*, void*);
  void cb_Open_i(Fl_Button*, void*);
  static void cb_Open(Fl_Button*, void*);
public:
  ~PsfGUI();
  void show(int argc, char* argv[]);
  template<typename T> void generatePsf();
  void readParameters();
};

class PsfObserver : public cosm::PsfUser {
public:
  PsfObserver(Fl_Progress* prog);
  ~PsfObserver();
  void update( PsfUser::Type type, int count, int total );
private:
  Fl_Progress* progress_; 
  PsfUser::Type type_; 
public:
  void make_window();
};
#endif
